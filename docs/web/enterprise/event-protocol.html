<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Protocol - Enterprise Architecture - jaato docs</title>
  <link rel="stylesheet" href="../assets/css/style.css">
  <style>
    .detail-hero {
      margin-bottom: 48px;
    }
    .detail-hero .lead {
      font-size: 18px;
      color: var(--color-text-secondary);
      line-height: 1.6;
      max-width: 720px;
    }
    .infography-full {
      margin: 32px 0;
      border: 1px solid var(--color-border);
      border-radius: 12px;
      overflow: hidden;
    }
    .infography-full img {
      width: 100%;
      display: block;
      background: var(--color-bg-secondary);
    }
    .infography-full .infography-caption {
      padding: 12px 20px;
      font-size: 13px;
      color: var(--color-text-secondary);
      border-top: 1px solid var(--color-border);
      text-align: center;
    }
    .detail-content h2 {
      margin-top: 48px;
    }
    .detail-content h3 {
      margin-top: 32px;
    }
    .detail-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0 24px 0;
    }
    .detail-content th,
    .detail-content td {
      text-align: left;
      padding: 10px 14px;
      border-bottom: 1px solid var(--color-border);
      font-size: 14px;
    }
    .detail-content th {
      font-weight: 600;
      color: var(--color-text);
    }
    .detail-content td {
      color: var(--color-text-secondary);
    }
    .detail-content code {
      font-size: 13px;
      padding: 2px 6px;
      background: var(--color-bg-secondary);
      border-radius: 4px;
    }
    .detail-content pre {
      background: var(--color-bg-secondary);
      border: 1px solid var(--color-border);
      border-radius: 8px;
      padding: 16px 20px;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
      margin: 16px 0 24px 0;
    }
    .detail-content pre code {
      background: none;
      padding: 0;
    }
    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      color: #0ea5e9;
      text-decoration: none;
      margin-top: 48px;
      padding-top: 24px;
      border-top: 1px solid var(--color-border);
    }
    .back-link:hover {
      color: #38bdf8;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <a href="../index.html" class="header-logo">
      jaato <span>docs</span>
    </a>
    <nav class="header-nav">
      <a href="../getting-started/quickstart.html">Quickstart</a>
      <a href="../api-reference/index.html">API Reference</a>
      <a href="https://github.com/apanoia/jaato" target="_blank">GitHub</a>
      <div class="header-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
        <input type="text" placeholder="Search docs... (press /)">
      </div>
    </nav>
  </header>

  <!-- Layout -->
  <div class="layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">Getting Started</div>
        <ul class="sidebar-nav">
          <li><a href="../getting-started/quickstart.html">Quickstart</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Core Concepts</div>
        <ul class="sidebar-nav">
          <li><a href="../core-concepts/client.html">Client</a></li>
          <li><a href="../core-concepts/plugins.html">Plugins</a></li>
          <li><a href="../core-concepts/tools.html">Tools</a></li>
          <li><a href="../core-concepts/providers.html">Providers</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Guides</div>
        <ul class="sidebar-nav">
          <li><a href="../guides/tool-plugins.html">Building Plugins</a></li>
          <li><a href="../guides/mcp-integration.html">MCP Integration</a></li>
          <li><a href="../guides/permissions.html">Permissions</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Enterprise</div>
        <ul class="sidebar-nav">
          <li><a href="index.html">Architecture Overview</a></li>
          <li><a href="model-harness.html">Model Harness</a></li>
          <li><a href="instruction-sources.html">Instruction Sources</a></li>
          <li><a href="tool-system.html">Tool System</a></li>
          <li><a href="permission-system.html">Permission System</a></li>
          <li><a href="event-protocol.html" class="active">Event Protocol</a></li>
          <li><a href="ipc-recovery.html">IPC Recovery</a></li>
          <li><a href="multi-provider.html">Multi-Provider</a></li>
          <li><a href="subagent-architecture.html">Subagent Architecture</a></li>
          <li><a href="opentelemetry.html">OpenTelemetry</a></li>
          <li><a href="proxy-kerberos.html">Proxy &amp; Kerberos</a></li>
          <li><a href="gc-system.html">GC System</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Contributing</div>
        <ul class="sidebar-nav">
          <li><a href="../contributing/index.html">Getting Started</a></li>
          <li><a href="../contributing/architecture.html">Architecture</a></li>
          <li><a href="../contributing/code-style.html">Code Style</a></li>
          <li><a href="../contributing/testing.html">Testing</a></li>
          <li><a href="../contributing/pull-requests.html">Pull Requests</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">API Reference</div>
        <ul class="sidebar-nav">
          <li><a href="../api-reference/index.html">Overview</a></li>
          <li><a href="../api-reference/jaato-client.html">JaatoClient</a></li>
          <li><a href="../api-reference/plugin-registry.html">PluginRegistry</a></li>
          <li><a href="../api-reference/types.html">Types</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Provider Reference</div>
        <ul class="sidebar-nav">
          <li><a href="../api-reference/providers/index.html">Overview</a></li>
          <li><a href="../api-reference/providers/anthropic.html">Anthropic</a></li>
          <li><a href="../api-reference/providers/google-genai.html">Google GenAI</a></li>
          <li><a href="../api-reference/providers/github-models.html">GitHub Models</a></li>
          <li><a href="../api-reference/providers/claude-cli.html">Claude CLI</a></li>
          <li><a href="../api-reference/providers/antigravity.html">Antigravity</a></li>
          <li><a href="../api-reference/providers/ollama.html">Ollama</a></li>
        </ul>
      </div>
    </aside>

    <!-- Main content -->
    <main class="main">
      <section class="detail-hero">
        <h1>Server-Client Event Protocol</h1>
        <p class="lead">
          JAATO uses a server-first architecture where all communication between server and client flows through a typed event protocol &mdash; a set of 40+ JSON-serializable dataclasses representing every meaningful state change. This design decouples the agentic runtime from UI concerns, enabling multiple clients to observe the same session simultaneously.
        </p>
      </section>

      <div class="infography-full">
        <a href="../assets/images/enterprise/jaato_event_protocol.png" target="_blank">
          <img src="../assets/images/enterprise/jaato_event_protocol.png" alt="Event Protocol Infography">
        </a>
        <div class="infography-caption">Click to open full-size image in a new tab</div>
      </div>

      <section class="detail-content">

        <h2 id="why-events">Why an Event Protocol?</h2>
        <p>
          Without events, the UI must be tightly coupled to the runtime: single client only, UI blocks the runtime, no remote clients, no reconnection. With events, the server runs as a daemon and emits semantic events, while clients decide how to render them. This enables:
        </p>
        <table>
          <thead>
            <tr><th>Principle</th><th>How Achieved</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Decoupling</strong></td><td>Server emits semantic events; clients decide how to render them</td></tr>
            <tr><td><strong>Multi-client</strong></td><td>Session manager broadcasts events to all attached clients</td></tr>
            <tr><td><strong>Reconnection</strong></td><td><code>emit_current_state()</code> replays full state on reconnect</td></tr>
            <tr><td><strong>Forward compatibility</strong></td><td>Unknown fields are filtered during deserialization</td></tr>
            <tr><td><strong>Thread safety</strong></td><td>Events queued via <code>call_soon_threadsafe()</code> from model threads</td></tr>
          </tbody>
        </table>

        <h2 id="event-categories">Event Categories</h2>
        <p>
          The 40+ event types are organized into functional categories:
        </p>
        <table>
          <thead>
            <tr><th>Category</th><th>Count</th><th>Direction</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Connection</strong></td><td>2</td><td>S&rarr;C</td><td>Client connect/disconnect lifecycle</td></tr>
            <tr><td><strong>Agent Lifecycle</strong></td><td>4</td><td>S&rarr;C</td><td>Agent creation, output streaming, status, completion</td></tr>
            <tr><td><strong>Tool Execution</strong></td><td>3</td><td>S&rarr;C</td><td>Tool start, live output, end with duration</td></tr>
            <tr><td><strong>Permission Flow</strong></td><td>4</td><td>S&harr;C</td><td>Request, input mode, response, resolution</td></tr>
            <tr><td><strong>Clarification Flow</strong></td><td>5</td><td>S&harr;C</td><td>Multi-question clarification sessions</td></tr>
            <tr><td><strong>Plan Management</strong></td><td>2</td><td>S&rarr;C</td><td>Plan creation, step updates, completion</td></tr>
            <tr><td><strong>Context &amp; Tokens</strong></td><td>4</td><td>S&rarr;C</td><td>Token usage, budget breakdown, turn progress</td></tr>
            <tr><td><strong>System Messages</strong></td><td>5</td><td>S&rarr;C</td><td>Info, errors, help, init progress, retries</td></tr>
            <tr><td><strong>Client Requests</strong></td><td>8</td><td>C&rarr;S</td><td>Messages, commands, config, history</td></tr>
            <tr><td><strong>Workspace Config</strong></td><td>8</td><td>S&harr;C</td><td>Workspace list, create, select, configure</td></tr>
          </tbody>
        </table>

        <h2 id="connection-lifecycle">Connection Lifecycle</h2>
        <p>
          When a client connects, it receives a <code>ConnectedEvent</code> with protocol version and server capabilities, followed by a <code>SessionInfoEvent</code> containing the full state snapshot: session metadata, available tools, model list, and command history. This allows the client to fully initialize without additional requests.
        </p>
        <p>
          On reconnection (e.g., after network drop), the server calls <code>emit_current_state()</code> which replays all relevant events: session info, tracked agents and their status, instruction budgets, and clears any stale pending permission/clarification requests.
        </p>

        <h2 id="agent-lifecycle">Agent Lifecycle Events</h2>
        <p>
          Each agent (main or subagent) follows a lifecycle represented by four event types:
        </p>
        <ul>
          <li><strong><code>AgentCreatedEvent</code></strong> &mdash; Agent registered with ID, type, optional profile name and icon</li>
          <li><strong><code>AgentOutputEvent</code></strong> &mdash; Streaming text chunks with source (<code>model</code>, <code>tool</code>, <code>system</code>), text, and mode (<code>write</code>, <code>append</code>, or <code>flush</code>). See <a href="#streaming-modes">Streaming Modes</a> below.</li>
          <li><strong><code>AgentStatusChangedEvent</code></strong> &mdash; Transitions between <code>active</code>, <code>idle</code>, <code>done</code>, <code>error</code></li>
          <li><strong><code>AgentCompletedEvent</code></strong> &mdash; Final summary with token usage and turns used</li>
        </ul>

        <h2 id="tool-events">Tool Execution Events</h2>
        <p>
          Tool execution emits three event types, correlated via <code>call_id</code> for parallel execution:
        </p>
        <ul>
          <li><strong><code>ToolCallStartEvent</code></strong> &mdash; Tool name, arguments, call ID</li>
          <li><strong><code>ToolOutputEvent</code></strong> &mdash; Live output chunks (tail-style streaming for long-running tools)</li>
          <li><strong><code>ToolCallEndEvent</code></strong> &mdash; Success/failure, duration in seconds, error message if failed</li>
        </ul>
        <p>
          During parallel execution, multiple <code>ToolCallStartEvent</code>s are emitted concurrently, and their <code>ToolOutputEvent</code>/<code>ToolCallEndEvent</code> events may interleave. The <code>call_id</code> allows clients to correctly associate events with their originating tool call.
        </p>

        <h2 id="permission-flow">Permission &amp; Clarification Flows</h2>
        <p>
          Permission is a four-event request-response cycle:
        </p>
        <ol>
          <li><strong><code>PermissionRequestedEvent</code></strong> (S&rarr;C) &mdash; Contains tool name, args, formatted prompt lines, format hint (e.g., <code>"diff"</code>), and available response options</li>
          <li><strong><code>PermissionInputModeEvent</code></strong> (S&rarr;C) &mdash; Signals client to switch input to permission mode</li>
          <li><strong><code>PermissionResponseRequest</code></strong> (C&rarr;S) &mdash; User's decision (<code>y</code>/<code>n</code>/<code>a</code>/<code>t</code>/<code>i</code>/<code>all</code>)</li>
          <li><strong><code>PermissionResolvedEvent</code></strong> (S&rarr;C) &mdash; Final grant/deny with method used</li>
        </ol>
        <p>
          Clarification follows a similar pattern but supports multiple sequential questions, each with options for single or multi-choice answers.
        </p>

        <h2 id="transport">Transport Layers</h2>
        <p>
          Events travel over two transport options:
        </p>
        <table>
          <thead>
            <tr><th>Aspect</th><th>IPC (Unix Socket)</th><th>WebSocket</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Protocol</strong></td><td>Length-prefixed JSON (4-byte big-endian u32 + UTF-8)</td><td>Native WebSocket text frames</td></tr>
            <tr><td><strong>Max message</strong></td><td>10 MB</td><td>Standard WS limits</td></tr>
            <tr><td><strong>Scope</strong></td><td>Local machine only</td><td>Local or remote</td></tr>
            <tr><td><strong>Thread safety</strong></td><td><code>call_soon_threadsafe()</code></td><td><code>run_coroutine_threadsafe()</code></td></tr>
          </tbody>
        </table>

        <h3>Ordering Guarantees</h3>
        <ul>
          <li><strong>Per-client FIFO</strong> &mdash; Events to a specific client maintain order</li>
          <li><strong>Broadcast consistency</strong> &mdash; All clients receive events in the same order</li>
          <li><strong>No batching</strong> &mdash; Each event is serialized and transmitted individually</li>
          <li><strong>At-most-once delivery</strong> &mdash; Disconnected clients miss events (recovered via <code>emit_current_state</code>)</li>
        </ul>

        <h2 id="streaming-modes">Streaming Modes (write / append / flush)</h2>
        <p>
          The <code>mode</code> field on <code>AgentOutputEvent</code> controls how the client should handle each chunk:
        </p>
        <table>
          <thead>
            <tr><th>Mode</th><th><code>text</code></th><th>Meaning</th></tr>
          </thead>
          <tbody>
            <tr><td><code>"write"</code></td><td>non-empty</td><td>Start a <strong>new</strong> output block. Previous block (if any) is finalized.</td></tr>
            <tr><td><code>"append"</code></td><td>non-empty</td><td>Continue appending to the <strong>current</strong> output block.</td></tr>
            <tr><td><code>"flush"</code></td><td>empty</td><td><strong>Streaming text is done.</strong> Finalize buffered output now &mdash; tool calls are about to start.</td></tr>
          </tbody>
        </table>
        <p>
          The <code>"flush"</code> signal is the only way to detect that model text streaming has ended within a turn. There is no separate "StreamEndEvent". The session emits <code>flush</code> immediately before executing tool calls, giving clients a synchronization point to:
        </p>
        <ul>
          <li>Finalize and render buffered text as one piece</li>
          <li>Transition the UI from "streaming text" to "executing tools" state</li>
          <li>Separate text output from tool output in non-streaming UIs (e.g., Telegram, Slack)</li>
        </ul>
        <p>
          <strong>Important:</strong> If the model responds with <strong>text only</strong> (no tool calls), no <code>flush</code> is emitted &mdash; the next event is <code>TurnCompletedEvent</code> directly. Clients must also flush their buffers on <code>TurnCompletedEvent</code>.
        </p>

        <h3>Canonical Event Sequence Within a Single Model Response</h3>
        <pre><code>AgentOutputEvent(source="model", mode="write")     &larr; new text block
AgentOutputEvent(source="model", mode="append")    &larr; more chunks...
AgentOutputEvent(source="model", mode="append")    &larr; ...
AgentOutputEvent(source="model", mode="flush")     &larr; text done, tools next
ToolCallStartEvent(tool_name="...")                 &larr; tool execution begins
ToolCallEndEvent(...)
...                                                 &larr; more tools if parallel
TurnProgressEvent(...)                              &larr; token accounting
&mdash; model may loop back (text &rarr; flush &rarr; tools) if tool results trigger more output &mdash;
TurnCompletedEvent(...)                             &larr; turn fully done</code></pre>

        <h2 id="client-buffering">Client Implementation Guide (Output Buffering)</h2>
        <p>
          Custom clients (Telegram bots, Slack integrations, web UIs, etc.) that cannot render incremental streaming must buffer output and emit it in discrete blocks. This section describes the canonical buffering pattern.
        </p>

        <h3>The Problem</h3>
        <p>
          The server emits <code>AgentOutputEvent</code> chunks as they stream from the model &mdash; potentially dozens per second. Clients like Telegram cannot update a message per chunk. They need to know <strong>when text is done</strong> so they can send one complete message, followed by tool call information.
        </p>

        <h3>Buffering Pattern</h3>
        <pre><code>from jaato_sdk.events import (
    AgentOutputEvent, ToolCallStartEvent, ToolCallEndEvent,
    TurnCompletedEvent, PermissionInputModeEvent,
)

text_buffer: list[str] = []
tool_calls: list[dict] = []

async for event in client.events():

    # --- Text streaming ---
    if isinstance(event, AgentOutputEvent) and event.source == "model":
        if event.mode == "flush":
            # Model text is done â€” emit buffered text now
            if text_buffer:
                send_message("".join(text_buffer))
                text_buffer.clear()
        elif event.mode in ("write", "append"):
            text_buffer.append(event.text)

    # --- Tool execution ---
    elif isinstance(event, ToolCallStartEvent):
        tool_calls.append({"name": event.tool_name, "args": event.tool_args})

    elif isinstance(event, ToolCallEndEvent):
        # Update tool status, show summary, etc.
        pass

    # --- Permission requests ---
    elif isinstance(event, PermissionInputModeEvent):
        # Show permission UI, collect response, then:
        await client.respond_to_permission(
            request_id=event.request_id,
            response=user_choice,  # "y", "n", "a", "never", etc.
        )

    # --- Turn completed ---
    elif isinstance(event, TurnCompletedEvent):
        # Flush any remaining text (text-only responses skip "flush")
        if text_buffer:
            send_message("".join(text_buffer))
            text_buffer.clear()
        # Show tool call summary if desired
        if tool_calls:
            send_tool_summary(tool_calls)
            tool_calls.clear()</code></pre>

        <h3>Key Rules</h3>
        <ol>
          <li><strong>Always flush on <code>TurnCompletedEvent</code></strong> &mdash; text-only responses (no tool calls) skip the <code>"flush"</code> signal and go straight to turn completion.</li>
          <li><strong><code>mode="flush"</code> has empty <code>text</code></strong> &mdash; don't append it to the buffer. It's a control signal, not content.</li>
          <li><strong>Multiple flush cycles per turn</strong> &mdash; a turn with tool calls may loop: text &rarr; flush &rarr; tools &rarr; text &rarr; flush &rarr; tools &rarr; turn completed. Reset your text buffer on each flush.</li>
          <li><strong><code>source</code> filtering matters</strong> &mdash; buffer <code>source="model"</code> text. Other sources (<code>"system"</code>, <code>"tool"</code>, plugin names) carry different content (tool output, system messages) that may need separate handling.</li>
        </ol>

      </section>

      <a href="index.html" class="back-link">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
        Back to Enterprise Overview
      </a>
    </main>
  </div>

  <script src="https://unpkg.com/lunr@2.3.9/lunr.min.js"></script>
  <script src="../assets/js/docs.js"></script>
</body>
</html>
