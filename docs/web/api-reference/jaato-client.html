<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JaatoClient - jaato docs</title>
  <link rel="stylesheet" href="../assets/css/style.css">
  <link rel="vcs-git" href="https://github.com/Jaato-framework-and-examples/jaato">
</head>
<body>
  <!-- Header -->
  <header class="header">
    <a href="../index.html" class="header-logo">
      jaato <span>docs</span>
    </a>
    <nav class="header-nav">
      <a href="../getting-started/quickstart.html">Quickstart</a>
      <a href="index.html">API Reference</a>
      <a href="https://github.com/Jaato-framework-and-examples/jaato" target="_blank">GitHub</a>
      <div class="header-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
        <input type="text" placeholder="Search docs... (press /)">
      </div>
    </nav>
  </header>

  <!-- Layout -->
  <div class="layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">Getting Started</div>
        <ul class="sidebar-nav">
          <li><a href="../getting-started/quickstart.html">Quickstart</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Core Concepts</div>
        <ul class="sidebar-nav">
          <li><a href="../core-concepts/client.html">Client</a></li>
          <li><a href="../core-concepts/plugins.html">Plugins</a></li>
          <li><a href="../core-concepts/tools.html">Tools</a></li>
          <li><a href="../core-concepts/providers.html">Providers</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Guides</div>
        <ul class="sidebar-nav">
          <li><a href="../guides/tool-plugins.html">Building Plugins</a></li>
          <li><a href="../guides/mcp-integration.html">MCP Integration</a></li>
          <li><a href="../guides/permissions.html">Permissions</a></li>
          <li><a href="../guides/connection-recovery.html">Connection Recovery</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">API Reference</div>
        <ul class="sidebar-nav">
          <li><a href="index.html">Overview</a></li>
          <li><a href="jaato-client.html" class="active">JaatoClient</a></li>
          <li><a href="jaato-runtime.html">JaatoRuntime</a></li>
          <li><a href="jaato-session.html">JaatoSession</a></li>
          <li><a href="ipc-recovery-client.html">IPCRecoveryClient</a></li>
          <li><a href="plugin-registry.html">PluginRegistry</a></li>
          <li><a href="tool-executor.html">ToolExecutor</a></li>
          <li><a href="types.html">Types</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Provider Reference</div>
        <ul class="sidebar-nav">
          <li><a href="providers/index.html">Overview</a></li>
          <li><a href="providers/anthropic.html">Anthropic</a></li>
          <li><a href="providers/google-genai.html">Google GenAI</a></li>
          <li><a href="providers/github-models.html">GitHub Models</a></li>
          <li><a href="providers/claude-cli.html">Claude CLI</a></li>
          <li><a href="providers/antigravity.html">Antigravity</a></li>
          <li><a href="providers/ollama.html">Ollama</a></li>
          <li><a href="providers/zhipuai.html">Zhipu AI</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Plugin Reference</div>
        <ul class="sidebar-nav">
          <li><a href="plugins/index.html">Overview</a></li>
          <li><a href="plugins/cli.html">CLI</a></li>
          <li><a href="plugins/file-edit.html">File Edit</a></li>
          <li><a href="plugins/filesystem-query.html">Filesystem Query</a></li>
          <li><a href="plugins/todo.html">Todo</a></li>
          <li><a href="plugins/web-search.html">Web Search</a></li>
          <li><a href="plugins/mcp.html">MCP</a></li>
          <li><a href="plugins/permission.html">Permission</a></li>
          <li><a href="plugins/session.html">Session</a></li>
          <li><a href="plugins/gc.html">GC</a></li>
          <li><a href="plugins/other.html">Other Plugins</a></li>
        </ul>
      </div>
    </aside>

    <!-- Main content -->
    <main class="main">
      <!-- Header -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h1>JaatoClient</h1>
          <p class="lead">
            The main entry point for the jaato framework. JaatoClient is a <strong>facade</strong>
            that wraps <code>JaatoRuntime</code> (shared resources) and <code>JaatoSession</code>
            (per-agent state), providing a unified interface for connecting to AI providers,
            configuring tools, and managing multi-turn conversations.
          </p>

          <div class="method-signature">
            <span class="token-keyword">from</span> jaato <span class="token-keyword">import</span> JaatoClient<br>
            <span class="token-keyword">from</span> shared <span class="token-keyword">import</span> JaatoRuntime, JaatoSession
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">Quick example</div>
          <div class="code-block">
            <pre><code class="language-python">from jaato import JaatoClient, PluginRegistry

client = JaatoClient()
client.connect()  # Reads JAATO_PROVIDER and MODEL_NAME from env

registry = PluginRegistry(model_name=client.model_name)
registry.discover()
registry.expose_tool("cli")
client.configure_tools(registry)

response = client.send_message(
    "List files in current directory",
    on_output=lambda s, t, m: print(t, end="")
)</code></pre>
          </div>
        </div>
      </section>

      <!-- Constructor -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="constructor">Constructor</h2>

          <h3>__init__</h3>
          <div class="method-signature">
            <span class="method-name">JaatoClient</span>(<span class="param">provider_name</span>: <span class="type">Optional[str]</span> = <span class="type">None</span>)
          </div>

          <p>Creates a new JaatoClient instance with the specified provider.</p>

          <ul class="param-list">
            <li>
              <span class="param-name">provider_name</span>
              <span class="param-type">str</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">
                The model provider to use. If not specified, reads from
                <code>JAATO_PROVIDER</code> env var, falling back to <code>"google_genai"</code>.
              </div>
            </li>
          </ul>

          <h3>Supported Providers</h3>
          <table>
            <thead>
              <tr><th>Provider</th><th>Name</th><th>Models</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><a href="providers/google-genai.html">Google GenAI</a></td>
                <td><code>google_genai</code></td>
                <td>Gemini 1.5, 2.0, 2.5</td>
              </tr>
              <tr>
                <td><a href="providers/anthropic.html">Anthropic</a></td>
                <td><code>anthropic</code></td>
                <td>Claude 3, 3.5, Sonnet 4, Opus 4</td>
              </tr>
              <tr>
                <td><a href="providers/github-models.html">GitHub Models</a></td>
                <td><code>github_models</code></td>
                <td>GPT-4o, Claude, Gemini, Llama</td>
              </tr>
              <tr>
                <td><a href="providers/claude-cli.html">Claude CLI</a></td>
                <td><code>claude_cli</code></td>
                <td>Uses Claude Pro/Max subscription</td>
              </tr>
              <tr>
                <td><a href="providers/antigravity.html">Antigravity</a></td>
                <td><code>antigravity</code></td>
                <td>Gemini 3, Claude (via Google)</td>
              </tr>
              <tr>
                <td><a href="providers/ollama.html">Ollama</a></td>
                <td><code>ollama</code></td>
                <td>Local models (Qwen, Llama, etc.)</td>
              </tr>
              <tr>
                <td><a href="providers/zhipuai.html">Zhipu AI</a></td>
                <td><code>zhipuai</code></td>
                <td>GLM-5, GLM-4.7, GLM-4.6, GLM-4.5</td>
              </tr>
            </tbody>
          </table>

          <div class="returns">
            <div class="returns-label">Returns</div>
            <div class="returns-type">JaatoClient</div>
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">Create client</div>
          <div class="code-block">
            <pre><code class="language-python"># Default: uses JAATO_PROVIDER env var or google_genai
client = JaatoClient()

# Google GenAI (Vertex AI / AI Studio)
client = JaatoClient(provider_name="google_genai")

# Anthropic Claude (API key or OAuth)
client = JaatoClient(provider_name="anthropic")

# GitHub Models (multi-model access)
client = JaatoClient(provider_name="github_models")

# Claude CLI (uses subscription, not API credits)
client = JaatoClient(provider_name="claude_cli")

# Antigravity (Google IDE backend)
client = JaatoClient(provider_name="antigravity")

# Ollama (local models)
client = JaatoClient(provider_name="ollama")</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Provider selection via env</div>
          <div class="code-block">
            <pre><code class="language-bash"># .env file
JAATO_PROVIDER=anthropic
MODEL_NAME=claude-sonnet-4-20250514

# Or for Ollama
JAATO_PROVIDER=ollama
OLLAMA_MODEL=qwen3:32b</code></pre>
          </div>
        </div>
      </section>

      <!-- Connection -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="connection">Connection</h2>

          <h3>connect</h3>
          <div class="method-signature">
            <span class="method-name">connect</span>(<span class="param">project</span>: <span class="type">Optional[str]</span> = <span class="type">None</span>, <span class="param">location</span>: <span class="type">Optional[str]</span> = <span class="type">None</span>, <span class="param">model</span>: <span class="type">Optional[str]</span> = <span class="type">None</span>) -> <span class="type">None</span>
          </div>

          <p>
            Establishes a connection to the AI provider. When called without arguments,
            reads configuration from environment variables (<code>JAATO_PROVIDER</code>,
            <code>MODEL_NAME</code>, and provider-specific variables).
          </p>

          <ul class="param-list">
            <li>
              <span class="param-name">project</span>
              <span class="param-type">str</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">Cloud project ID (required for Vertex AI, read from <code>JAATO_GOOGLE_PROJECT</code> if not set)</div>
            </li>
            <li>
              <span class="param-name">location</span>
              <span class="param-type">str</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">Provider region (required for Vertex AI, read from <code>JAATO_GOOGLE_LOCATION</code> if not set)</div>
            </li>
            <li>
              <span class="param-name">model</span>
              <span class="param-type">str</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">Model name. If not provided, reads from <code>MODEL_NAME</code> env var (or provider-specific vars like <code>OLLAMA_MODEL</code>)</div>
            </li>
          </ul>

          <h3 id="is-connected">is_connected <span class="badge badge-property">property</span></h3>
          <p>Returns <code>True</code> if the client is connected to a provider.</p>

          <h3 id="model-name">model_name <span class="badge badge-property">property</span></h3>
          <p>Returns the current model name, or <code>None</code> if not connected.</p>

          <h3>list_available_models</h3>
          <div class="method-signature">
            <span class="method-name">list_available_models</span>(<span class="param">prefix</span>: <span class="type">Optional[str]</span> = <span class="type">None</span>) -> <span class="type">List[str]</span>
          </div>
          <p>Lists available models from the provider, optionally filtered by prefix.</p>

          <h3 id="get-runtime">get_runtime</h3>
          <div class="method-signature">
            <span class="method-name">get_runtime</span>() -> <span class="type">JaatoRuntime</span>
          </div>
          <p>
            Returns the underlying <code>JaatoRuntime</code> for advanced use cases like
            creating subagent sessions. The runtime holds shared resources (provider config,
            registry, permissions, ledger).
          </p>

          <h3 id="get-session">get_session</h3>
          <div class="method-signature">
            <span class="method-name">get_session</span>() -> <span class="type">JaatoSession</span>
          </div>
          <p>
            Returns the underlying <code>JaatoSession</code> for direct session manipulation.
          </p>

          <h3 id="verify-auth">verify_auth</h3>
          <div class="method-signature">
            <span class="method-name">verify_auth</span>(<br>
            &nbsp;&nbsp;<span class="param">allow_interactive</span>: <span class="type">bool</span> = <span class="type">False</span>,<br>
            &nbsp;&nbsp;<span class="param">on_message</span>: <span class="type">Optional[Callable[[str], None]]</span> = <span class="type">None</span><br>
            ) -> <span class="type">bool</span>
          </div>
          <p>
            Verify authentication before loading tools. Call this <strong>after</strong>
            <code>connect()</code> but <strong>before</strong> <code>configure_tools()</code>
            for providers that support interactive login (like Anthropic OAuth).
          </p>

          <ul class="param-list">
            <li>
              <span class="param-name">allow_interactive</span>
              <span class="param-type">bool</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">
                If True and auth is not configured, attempt interactive login
                (e.g., browser-based OAuth). Default: False.
              </div>
            </li>
            <li>
              <span class="param-name">on_message</span>
              <span class="param-type">Callable[[str], None]</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">
                Callback for status messages during login (e.g., "Opening browser...").
              </div>
            </li>
          </ul>

          <div class="returns">
            <div class="returns-label">Returns</div>
            <div class="returns-type">bool - True if auth is valid, False if failed or not completed</div>
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">Connection (recommended: env-based)</div>
          <div class="code-block">
            <pre><code class="language-python"># Reads JAATO_PROVIDER and MODEL_NAME from env
client = JaatoClient()
client.connect()

# Check connection
if client.is_connected:
    print(f"Connected to {client.model_name}")</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Connection with explicit overrides</div>
          <div class="code-block">
            <pre><code class="language-python"># Override provider and model in code
client = JaatoClient(provider_name="anthropic")
client.connect(model="claude-sonnet-4-20250514")

# Google GenAI (Vertex AI) with project/location
client = JaatoClient(provider_name="google_genai")
client.connect(
    project="my-gcp-project",
    location="us-central1",
    model="gemini-2.5-flash"
)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Runtime &amp; Session access</div>
          <div class="code-block">
            <pre><code class="language-python"># Access runtime for subagent creation
runtime = client.get_runtime()
sub_session = runtime.create_session(
    model="claude-sonnet-4-20250514",
    tools=["cli", "web_search"],
    system_instructions="You are a researcher."
)
sub_response = sub_session.send_message("Research...")

# Access main session directly
main_session = client.get_session()
history = main_session.get_history()</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">OAuth authentication flow</div>
          <div class="code-block">
            <pre><code class="language-python"># For providers with OAuth (Anthropic, Antigravity)
client = JaatoClient(provider_name="anthropic")
client.connect()  # Reads MODEL_NAME from env

# Verify auth - triggers browser OAuth if needed
if not client.verify_auth(
    allow_interactive=True,
    on_message=lambda msg: print(f"Auth: {msg}")
):
    print("Authentication failed")
    return

# Now safe to configure tools
client.configure_tools(registry, permission_plugin, ledger)</code></pre>
          </div>
        </div>
      </section>

      <!-- Tool Configuration -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="tool-configuration">Tool Configuration</h2>

          <h3>configure_tools</h3>
          <div class="method-signature">
            <span class="method-name">configure_tools</span>(<br>
            &nbsp;&nbsp;<span class="param">registry</span>: <span class="type">PluginRegistry</span>,<br>
            &nbsp;&nbsp;<span class="param">permission_plugin</span>: <span class="type">Optional[PermissionPlugin]</span> = <span class="type">None</span>,<br>
            &nbsp;&nbsp;<span class="param">ledger</span>: <span class="type">Optional[TokenLedger]</span> = <span class="type">None</span><br>
            ) -> <span class="type">None</span>
          </div>

          <p>
            Configures the client with tools from a plugin registry. This is the
            recommended way to set up tools.
          </p>

          <ul class="param-list">
            <li>
              <span class="param-name">registry</span>
              <span class="param-type">PluginRegistry</span>
              <span class="param-required">required</span>
              <div class="param-desc">Registry containing exposed tool plugins</div>
            </li>
            <li>
              <span class="param-name">permission_plugin</span>
              <span class="param-type">PermissionPlugin</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">Plugin for permission checking before tool execution</div>
            </li>
            <li>
              <span class="param-name">ledger</span>
              <span class="param-type">TokenLedger</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">Token accounting ledger</div>
            </li>
          </ul>

          <h3>configure_plugins_only</h3>
          <div class="method-signature">
            <span class="method-name">configure_plugins_only</span>(<br>
            &nbsp;&nbsp;<span class="param">registry</span>: <span class="type">PluginRegistry</span>,<br>
            &nbsp;&nbsp;<span class="param">permission_plugin</span>: <span class="type">Optional[PermissionPlugin]</span> = <span class="type">None</span>,<br>
            &nbsp;&nbsp;<span class="param">ledger</span>: <span class="type">Optional[TokenLedger]</span> = <span class="type">None</span><br>
            ) -> <span class="type">None</span>
          </div>

          <p>
            Configure plugins without creating a provider session. Use this when
            authentication is pending and you need user commands available but
            can't connect to the model yet.
          </p>

          <h3>configure_custom_tools</h3>
          <div class="method-signature">
            <span class="method-name">configure_custom_tools</span>(<br>
            &nbsp;&nbsp;<span class="param">tools</span>: <span class="type">List[ToolSchema]</span>,<br>
            &nbsp;&nbsp;<span class="param">executors</span>: <span class="type">Dict[str, Callable]</span>,<br>
            &nbsp;&nbsp;<span class="param">ledger</span>: <span class="type">Optional[TokenLedger]</span> = <span class="type">None</span>,<br>
            &nbsp;&nbsp;<span class="param">system_instruction</span>: <span class="type">Optional[str]</span> = <span class="type">None</span><br>
            ) -> <span class="type">None</span>
          </div>

          <p>
            Configures tools directly without using a registry. Useful for custom
            tool implementations.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Using PluginRegistry</div>
          <div class="code-block">
            <pre><code class="language-python">from jaato import JaatoClient, PluginRegistry
from shared import PermissionPlugin, TokenLedger

client = JaatoClient()
client.connect()  # Reads JAATO_PROVIDER and MODEL_NAME from env

# Setup registry
registry = PluginRegistry(model_name=client.model_name)
registry.discover()
registry.expose_tool("cli")
registry.expose_tool("file_edit")

# Optional: permission control
perm = PermissionPlugin()
perm.initialize({"config_path": "perms.json"})

# Optional: token accounting
ledger = TokenLedger()

# Configure
client.configure_tools(
    registry,
    permission_plugin=perm,
    ledger=ledger
)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Custom tools</div>
          <div class="code-block">
            <pre><code class="language-python">from jaato import ToolSchema

# Define custom tool
def get_weather(city: str) -> str:
    return f"Weather in {city}: Sunny, 72F"

tools = [
    ToolSchema(
        name="get_weather",
        description="Get current weather",
        parameters={
            "type": "object",
            "properties": {
                "city": {"type": "string"}
            },
            "required": ["city"]
        }
    )
]

executors = {"get_weather": get_weather}

client.configure_custom_tools(
    tools=tools,
    executors=executors
)</code></pre>
          </div>
        </div>
      </section>

      <!-- Messaging -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="messaging">Messaging</h2>

          <h3>send_message</h3>
          <div class="method-signature">
            <span class="method-name">send_message</span>(<br>
            &nbsp;&nbsp;<span class="param">message</span>: <span class="type">str</span>,<br>
            &nbsp;&nbsp;<span class="param">on_output</span>: <span class="type">Optional[OutputCallback]</span> = <span class="type">None</span>,<br>
            &nbsp;&nbsp;<span class="param">on_usage_update</span>: <span class="type">Optional[UsageUpdateCallback]</span> = <span class="type">None</span>,<br>
            &nbsp;&nbsp;<span class="param">on_gc_threshold</span>: <span class="type">Optional[GCThresholdCallback]</span> = <span class="type">None</span><br>
            ) -> <span class="type">str</span>
          </div>

          <p>
            Sends a message and returns the final response. Handles the full tool
            execution loop internally, calling callbacks for real-time streaming
            and usage updates.
          </p>

          <ul class="param-list">
            <li>
              <span class="param-name">message</span>
              <span class="param-type">str</span>
              <span class="param-required">required</span>
              <div class="param-desc">The user message to send</div>
            </li>
            <li>
              <span class="param-name">on_output</span>
              <span class="param-type">OutputCallback</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">
                Callback for real-time output: <code>(source: str, text: str, mode: str) -> None</code>
              </div>
            </li>
            <li>
              <span class="param-name">on_usage_update</span>
              <span class="param-type">UsageUpdateCallback</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">
                Callback for real-time token usage: <code>(usage: TokenUsage) -> None</code>
              </div>
            </li>
            <li>
              <span class="param-name">on_gc_threshold</span>
              <span class="param-type">GCThresholdCallback</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">
                Callback when GC threshold is crossed during streaming:
                <code>(percent_used: float, threshold: float) -> None</code>
              </div>
            </li>
          </ul>

          <div class="returns">
            <div class="returns-label">Returns</div>
            <div class="returns-type">str - The final response text</div>
          </div>

          <h3>send_message_with_parts</h3>
          <div class="method-signature">
            <span class="method-name">send_message_with_parts</span>(<br>
            &nbsp;&nbsp;<span class="param">parts</span>: <span class="type">List[Part]</span>,<br>
            &nbsp;&nbsp;<span class="param">on_output</span>: <span class="type">OutputCallback</span><br>
            ) -> <span class="type">str</span>
          </div>

          <p>Sends a multimodal message with multiple parts (text, images, etc.).</p>

          <h3>generate</h3>
          <div class="method-signature">
            <span class="method-name">generate</span>(<br>
            &nbsp;&nbsp;<span class="param">prompt</span>: <span class="type">str</span>,<br>
            &nbsp;&nbsp;<span class="param">ledger</span>: <span class="type">Optional[TokenLedger]</span> = <span class="type">None</span><br>
            ) -> <span class="type">str</span>
          </div>

          <p>
            Simple one-shot generation without tools or conversation history.
            Useful for quick completions.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">send_message</div>
          <div class="code-block">
            <pre><code class="language-python"># Output callback
def on_output(source, text, mode):
    """
    source: "model", plugin name, or "system"
    text: output text
    mode: "write" (new) or "append" (continue)
    """
    if mode == "write":
        print(f"\n[{source}]", end=" ")
    print(text, end="")

# Send message
response = client.send_message(
    "What files are in this directory?",
    on_output=on_output
)

print(f"\n\nFinal: {response}")</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Multimodal message</div>
          <div class="code-block">
            <pre><code class="language-python">from jaato import Part, Attachment

# Create parts with image
parts = [
    Part.from_text("What's in this image?"),
    Part(inline_data=Attachment(
        mime_type="image/png",
        data=open("image.png", "rb").read()
    ))
]

response = client.send_message_with_parts(
    parts,
    on_output=on_output
)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Simple generation</div>
          <div class="code-block">
            <pre><code class="language-python"># One-shot, no tools, no history
result = client.generate("What is 2 + 2?")
print(result)  # "4"</code></pre>
          </div>
        </div>
      </section>

      <!-- History -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="history">History Management</h2>

          <h3>get_history</h3>
          <div class="method-signature">
            <span class="method-name">get_history</span>() -> <span class="type">List[Message]</span>
          </div>
          <p>Returns the full conversation history as a list of <code>Message</code> objects.</p>

          <h3>reset_session</h3>
          <div class="method-signature">
            <span class="method-name">reset_session</span>(<span class="param">history</span>: <span class="type">Optional[List[Message]]</span> = <span class="type">None</span>) -> <span class="type">None</span>
          </div>
          <p>
            Clears the current session. Optionally initializes with a new history.
          </p>

          <h3>get_turn_accounting</h3>
          <div class="method-signature">
            <span class="method-name">get_turn_accounting</span>() -> <span class="type">List[Dict[str, Any]]</span>
          </div>
          <p>Returns per-turn statistics including token counts and timing.</p>

          <h3>get_turn_boundaries</h3>
          <div class="method-signature">
            <span class="method-name">get_turn_boundaries</span>() -> <span class="type">List[int]</span>
          </div>
          <p>Returns indices marking the start of each turn in the history.</p>

          <h3>revert_to_turn</h3>
          <div class="method-signature">
            <span class="method-name">revert_to_turn</span>(<span class="param">turn_id</span>: <span class="type">int</span>) -> <span class="type">Dict[str, Any]</span>
          </div>
          <p>Reverts the conversation to a specific turn, removing subsequent messages.</p>

          <h3>get_context_limit</h3>
          <div class="method-signature">
            <span class="method-name">get_context_limit</span>() -> <span class="type">int</span>
          </div>
          <p>Returns the model's context window size in tokens.</p>

          <h3>get_context_usage</h3>
          <div class="method-signature">
            <span class="method-name">get_context_usage</span>() -> <span class="type">Dict[str, Any]</span>
          </div>
          <p>Returns current context usage statistics.</p>
        </div>
        <div class="panel-code">
          <div class="code-label">Working with history</div>
          <div class="code-block">
            <pre><code class="language-python"># Get conversation history
history = client.get_history()
for msg in history:
    print(f"{msg.role}: {msg.text[:50]}...")

# Check turn info
turns = client.get_turn_boundaries()
print(f"Conversation has {len(turns)} turns")

# Get per-turn stats
accounting = client.get_turn_accounting()
for turn in accounting:
    print(f"Turn {turn['turn_id']}: "
          f"{turn['tokens']} tokens")

# Revert to earlier turn
client.revert_to_turn(2)

# Clear and start fresh
client.reset_session()

# Reset with custom history
client.reset_session(history=custom_history)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Context management</div>
          <div class="code-block">
            <pre><code class="language-python"># Check context limits
limit = client.get_context_limit()
usage = client.get_context_usage()

print(f"Limit: {limit} tokens")
print(f"Used: {usage['total_tokens']} tokens")
print(f"Available: {limit - usage['total_tokens']}")</code></pre>
          </div>
        </div>
      </section>

      <!-- Garbage Collection -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="gc">Garbage Collection</h2>

          <p>
            For long conversations, GC plugins help manage context window limits
            by automatically removing or summarizing older messages.
          </p>

          <h3>set_gc_plugin</h3>
          <div class="method-signature">
            <span class="method-name">set_gc_plugin</span>(<br>
            &nbsp;&nbsp;<span class="param">plugin</span>: <span class="type">GCPlugin</span>,<br>
            &nbsp;&nbsp;<span class="param">config</span>: <span class="type">Optional[GCConfig]</span> = <span class="type">None</span><br>
            ) -> <span class="type">None</span>
          </div>
          <p>Enables automatic garbage collection with the specified plugin.</p>

          <h3>remove_gc_plugin</h3>
          <div class="method-signature">
            <span class="method-name">remove_gc_plugin</span>() -> <span class="type">None</span>
          </div>
          <p>Disables garbage collection.</p>

          <h3>manual_gc</h3>
          <div class="method-signature">
            <span class="method-name">manual_gc</span>() -> <span class="type">GCResult</span>
          </div>
          <p>Manually triggers garbage collection and returns the result.</p>

          <h3>get_gc_history</h3>
          <div class="method-signature">
            <span class="method-name">get_gc_history</span>() -> <span class="type">List[GCResult]</span>
          </div>
          <p>Returns the history of GC operations performed.</p>
        </div>
        <div class="panel-code">
          <div class="code-label">Setup GC</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.plugins.gc_truncate import (
    create_plugin as create_gc
)
from shared.plugins.gc import GCConfig

# Create GC plugin
gc_plugin = create_gc()
gc_plugin.initialize({
    "preserve_recent_turns": 10
})

# Configure with threshold (or use JAATO_GC_THRESHOLD env var)
config = GCConfig(
    threshold_percent=75.0,  # overrides env var default
    check_before_send=True
)

client.set_gc_plugin(gc_plugin, config)

# Manual GC
result = client.manual_gc()
print(f"Freed {result.tokens_freed} tokens")

# Check GC history
for gc in client.get_gc_history():
    print(f"GC at turn {gc.turn}: "
          f"{gc.tokens_freed} freed")

# Disable GC
client.remove_gc_plugin()</code></pre>
          </div>
        </div>
      </section>

      <!-- Sessions -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="sessions">Session Persistence</h2>

          <p>
            Session plugins enable saving and resuming conversations across
            application restarts.
          </p>

          <h3>set_session_plugin</h3>
          <div class="method-signature">
            <span class="method-name">set_session_plugin</span>(<br>
            &nbsp;&nbsp;<span class="param">plugin</span>: <span class="type">SessionPlugin</span>,<br>
            &nbsp;&nbsp;<span class="param">config</span>: <span class="type">Optional[SessionConfig]</span> = <span class="type">None</span><br>
            ) -> <span class="type">None</span>
          </div>

          <h3>save_session</h3>
          <div class="method-signature">
            <span class="method-name">save_session</span>(<br>
            &nbsp;&nbsp;<span class="param">session_id</span>: <span class="type">Optional[str]</span> = <span class="type">None</span>,<br>
            &nbsp;&nbsp;<span class="param">user_inputs</span>: <span class="type">Optional[List[str]]</span> = <span class="type">None</span><br>
            ) -> <span class="type">str</span>
          </div>
          <p>Saves the current session and returns the session ID.</p>

          <h3>resume_session</h3>
          <div class="method-signature">
            <span class="method-name">resume_session</span>(<span class="param">session_id</span>: <span class="type">str</span>) -> <span class="type">SessionState</span>
          </div>
          <p>Loads a previously saved session.</p>

          <h3>list_sessions</h3>
          <div class="method-signature">
            <span class="method-name">list_sessions</span>() -> <span class="type">List[SessionInfo]</span>
          </div>
          <p>Returns a list of all saved sessions.</p>

          <h3>delete_session</h3>
          <div class="method-signature">
            <span class="method-name">delete_session</span>(<span class="param">session_id</span>: <span class="type">str</span>) -> <span class="type">bool</span>
          </div>
          <p>Deletes a saved session.</p>
        </div>
        <div class="panel-code">
          <div class="code-label">Session persistence</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.plugins.session import (
    create_plugin as create_session
)
from shared.plugins.session import SessionConfig

# Setup session plugin
session = create_session()
session.initialize({
    "storage_path": ".jaato/sessions"
})

config = SessionConfig(
    auto_resume_last=True
)

client.set_session_plugin(session, config)

# ... have conversation ...

# Save session
session_id = client.save_session()
print(f"Saved: {session_id}")

# Later: resume
client.resume_session(session_id)

# List all sessions
for info in client.list_sessions():
    print(f"{info.id}: {info.created_at}")

# Delete old session
client.delete_session(old_session_id)</code></pre>
          </div>
        </div>
      </section>

      <!-- Thinking Mode -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="thinking-mode">Thinking Mode</h2>

          <p>
            For providers that support extended thinking (Anthropic Claude, Gemini),
            you can enable and configure thinking mode to get more thorough reasoning.
          </p>

          <h3>set_thinking_plugin</h3>
          <div class="method-signature">
            <span class="method-name">set_thinking_plugin</span>(<span class="param">plugin</span>: <span class="type">ThinkingPlugin</span>) -> <span class="type">None</span>
          </div>
          <p>Set the thinking plugin for controlling reasoning modes.</p>

          <h3>remove_thinking_plugin</h3>
          <div class="method-signature">
            <span class="method-name">remove_thinking_plugin</span>() -> <span class="type">None</span>
          </div>
          <p>Remove the thinking plugin.</p>

          <h3>set_thinking_config</h3>
          <div class="method-signature">
            <span class="method-name">set_thinking_config</span>(<span class="param">config</span>: <span class="type">ThinkingConfig</span>) -> <span class="type">None</span>
          </div>
          <p>Set thinking mode configuration directly (bypasses plugin).</p>

          <h3>get_thinking_config</h3>
          <div class="method-signature">
            <span class="method-name">get_thinking_config</span>() -> <span class="type">Optional[ThinkingConfig]</span>
          </div>
          <p>Get current thinking configuration.</p>

          <h3>supports_thinking</h3>
          <div class="method-signature">
            <span class="method-name">supports_thinking</span>() -> <span class="type">bool</span>
          </div>
          <p>Check if the current provider supports thinking mode.</p>
        </div>
        <div class="panel-code">
          <div class="code-label">Enable thinking mode</div>
          <div class="code-block">
            <pre><code class="language-python">from jaato_sdk.plugins.model_provider.types import ThinkingConfig

# Check support
if client.supports_thinking():
    # Enable thinking with budget
    client.set_thinking_config(ThinkingConfig(
        enabled=True,
        budget=10000  # Max thinking tokens
    ))

    response = client.send_message(
        "Analyze this complex problem...",
        on_output=on_output
    )

    # Disable thinking
    client.set_thinking_config(ThinkingConfig(enabled=False))</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Using thinking plugin</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.plugins.thinking import create_plugin as create_thinking

# Create and set thinking plugin
thinking = create_thinking()
thinking.initialize({"default_budget": 8192})
client.set_thinking_plugin(thinking)

# User commands now available:
# /thinking on - enable thinking
# /thinking off - disable thinking
# /thinking budget 16000 - set budget</code></pre>
          </div>
        </div>
      </section>

      <!-- UI Hooks -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="ui-hooks">UI Hooks</h2>

          <p>
            For rich terminal UIs, you can set hooks to receive agent lifecycle
            events, enabling progress tracking and accounting displays.
          </p>

          <h3>set_ui_hooks</h3>
          <div class="method-signature">
            <span class="method-name">set_ui_hooks</span>(<span class="param">hooks</span>: <span class="type">AgentUIHooks</span>) -> <span class="type">None</span>
          </div>
          <p>
            Set UI hooks for agent lifecycle events. The hooks receive callbacks
            for agent creation, output, turn completion, context updates, and more.
          </p>

          <h3>set_terminal_width</h3>
          <div class="method-signature">
            <span class="method-name">set_terminal_width</span>(<span class="param">width</span>: <span class="type">int</span>) -> <span class="type">None</span>
          </div>
          <p>
            Set the terminal width for formatting. Affects enrichment notification
            formatting to properly wrap and align text.
          </p>

          <h3>set_presentation_context</h3>
          <div class="method-signature">
            <span class="method-name">set_presentation_context</span>(<span class="param">ctx</span>: <span class="type">PresentationContext</span>) -> <span class="type">None</span>
          </div>
          <p>
            Set display capabilities for the connected client. The context is
            injected into the model's system instructions so it adapts output
            format (e.g. vertical lists on narrow displays, full tables on wide
            ones). Also updates <code>terminal_width</code> for backwards
            compatibility. See <a href="types.html#presentation-context">PresentationContext</a>.
          </p>

          <h3>get_model_completions</h3>
          <div class="method-signature">
            <span class="method-name">get_model_completions</span>(<span class="param">args</span>: <span class="type">List[str]</span>) -> <span class="type">List[CommandCompletion]</span>
          </div>
          <p>Get completions for the model command (for shell autocomplete).</p>
        </div>
        <div class="panel-code">
          <div class="code-label">Implementing UI hooks</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.plugins.subagent.ui_hooks import AgentUIHooks

class MyUIHooks(AgentUIHooks):
    def on_agent_created(self, agent_id, agent_name, ...):
        print(f"Agent {agent_name} created")

    def on_agent_output(self, agent_id, source, text, mode):
        # Display streaming output
        print(text, end="")

    def on_agent_turn_completed(self, agent_id, turn_number,
                                prompt_tokens, output_tokens, ...):
        print(f"Turn {turn_number}: {output_tokens} tokens")

    def on_agent_context_updated(self, agent_id, total_tokens,
                                 percent_used, ...):
        print(f"Context: {percent_used:.1f}% used")

# Set hooks on client
client.set_ui_hooks(MyUIHooks())
client.set_terminal_width(120)

# Or set full presentation context
from jaato import PresentationContext, ClientType
client.set_presentation_context(PresentationContext(
    content_width=120,
    client_type=ClientType.TERMINAL,
))</code></pre>
          </div>
        </div>
      </section>

      <!-- User Commands -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="user-commands">User Commands</h2>

          <p>
            Plugins can expose user-facing commands that can be executed
            during a conversation.
          </p>

          <h3>get_user_commands</h3>
          <div class="method-signature">
            <span class="method-name">get_user_commands</span>() -> <span class="type">Dict[str, UserCommand]</span>
          </div>
          <p>Returns all available user commands from exposed plugins.</p>

          <h3>execute_user_command</h3>
          <div class="method-signature">
            <span class="method-name">execute_user_command</span>(<br>
            &nbsp;&nbsp;<span class="param">command_name</span>: <span class="type">str</span>,<br>
            &nbsp;&nbsp;<span class="param">args</span>: <span class="type">Optional[Dict]</span> = <span class="type">None</span><br>
            ) -> <span class="type">tuple[Any, bool]</span>
          </div>
          <p>Executes a user command and returns (result, share_with_model).</p>
        </div>
        <div class="panel-code">
          <div class="code-label">User commands</div>
          <div class="code-block">
            <pre><code class="language-python"># List available commands
commands = client.get_user_commands()
for name, cmd in commands.items():
    print(f"/{name}: {cmd.description}")

# Execute a command
result, share = client.execute_user_command(
    "todo_list",
    args={"filter": "pending"}
)

print(result)

# If share is True, add result to conversation
if share:
    client.send_message(
        f"Command result: {result}",
        on_output=on_output
    )</code></pre>
          </div>
        </div>
      </section>

      <!-- Streaming & Cancellation -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="streaming-cancellation">Streaming & Cancellation</h2>

          <p>
            jaato supports interruptible requests with streaming output and
            graceful cancellation. This allows stopping long-running operations
            mid-turn.
          </p>

          <h3>stop</h3>
          <div class="method-signature">
            <span class="method-name">stop</span>() -> <span class="type">bool</span>
          </div>
          <p>
            Request cancellation of the current operation. Thread-safe.
            Returns <code>True</code> if a cancellation was requested, <code>False</code>
            if no operation was in progress.
          </p>

          <h3 id="is-processing">is_processing <span class="badge badge-property">property</span></h3>
          <p>Returns <code>True</code> if a message is currently being processed.</p>

          <h3 id="supports-stop">supports_stop <span class="badge badge-property">property</span></h3>
          <p>
            Returns <code>True</code> if the current provider supports mid-turn cancellation.
            Check this before calling <code>stop()</code> to know if it will be effective.
          </p>

          <h3>set_streaming_enabled</h3>
          <div class="method-signature">
            <span class="method-name">set_streaming_enabled</span>(<span class="param">enabled</span>: <span class="type">bool</span>) -> <span class="type">None</span>
          </div>
          <p>
            Enable or disable streaming mode. When enabled, uses provider's streaming
            API for real-time token output and cancellation support.
          </p>

          <ul class="param-list">
            <li>
              <span class="param-name">enabled</span>
              <span class="param-type">bool</span>
              <span class="param-required">required</span>
              <div class="param-desc">Whether to enable streaming mode.</div>
            </li>
          </ul>

          <div class="callout callout-info">
            <div class="callout-title">Streaming Requirements</div>
            Streaming must be enabled for cancellation to take effect mid-generation.
            Without streaming, cancellation will only interrupt between API calls
            (e.g., during retry backoff or between tool executions).
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">Cancellation example</div>
          <div class="code-block">
            <pre><code class="language-python">import threading
from jaato import JaatoClient, CancelledException

client = JaatoClient()
client.connect()  # Reads JAATO_PROVIDER and MODEL_NAME from env
# ... configure tools ...

# Enable streaming for mid-generation cancellation
client.set_streaming_enabled(True)

# Cancel after 10 seconds
def cancel_after_timeout():
    time.sleep(10)
    if client.is_processing:
        print("Timeout - stopping...")
        client.stop()

timer = threading.Thread(target=cancel_after_timeout)
timer.start()

try:
    response = client.send_message(
        "Write a very long essay...",
        on_output=lambda s, t, m: print(t, end="")
    )
    print(f"\n\nFinished normally")
except CancelledException:
    print(f"\n\nRequest was cancelled")
finally:
    timer.join()</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Streaming output</div>
          <div class="code-block">
            <pre><code class="language-python"># With streaming enabled, tokens arrive
# incrementally via the on_output callback
client.set_streaming_enabled(True)

def on_output(source, text, mode):
    # mode="write" for new block
    # mode="append" for continuation
    print(text, end="", flush=True)

response = client.send_message(
    "Count from 1 to 100",
    on_output=on_output
)
# Output appears token-by-token!</code></pre>
          </div>
        </div>
      </section>

      <!-- Rate Limiting -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="rate-limiting">Rate Limiting</h2>

          <p>
            jaato provides both <strong>proactive</strong> (request pacing) and
            <strong>reactive</strong> (retry with backoff) rate limiting to handle
            provider API limits gracefully.
          </p>

          <h3>Environment Variables</h3>
          <p>Configure rate limiting via environment variables:</p>

          <table class="param-table">
            <thead>
              <tr><th>Variable</th><th>Default</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>AI_REQUEST_INTERVAL</code></td>
                <td><code>0</code></td>
                <td>Minimum seconds between API requests (0 = disabled)</td>
              </tr>
              <tr>
                <td><code>AI_RETRY_ATTEMPTS</code></td>
                <td><code>5</code></td>
                <td>Max retry attempts on 429 errors</td>
              </tr>
              <tr>
                <td><code>AI_RETRY_BASE_DELAY</code></td>
                <td><code>1.0</code></td>
                <td>Initial retry delay in seconds</td>
              </tr>
              <tr>
                <td><code>AI_RETRY_MAX_DELAY</code></td>
                <td><code>30.0</code></td>
                <td>Maximum retry delay in seconds</td>
              </tr>
              <tr>
                <td><code>AI_RETRY_LOG_SILENT</code></td>
                <td><code>false</code></td>
                <td>Suppress retry log messages</td>
              </tr>
            </tbody>
          </table>

          <h3>set_retry_callback</h3>
          <div class="method-signature">
            <span class="method-name">set_retry_callback</span>(<br>
            &nbsp;&nbsp;<span class="param">callback</span>: <span class="type">Optional[RetryCallback]</span><br>
            ) -> <span class="type">None</span>
          </div>
          <p>
            Set a callback to receive retry notifications. Use this to route
            retry messages to a status bar or queue instead of console output.
          </p>

          <ul class="param-list">
            <li>
              <span class="param-name">callback</span>
              <span class="param-type">RetryCallback</span>
              <span class="param-optional">optional</span>
              <div class="param-desc">
                Function signature: <code>(message: str, attempt: int, max_attempts: int, delay: float) -> None</code>.
                Set to <code>None</code> to revert to console output.
              </div>
            </li>
          </ul>
        </div>
        <div class="panel-code">
          <div class="code-label">Proactive pacing (.env)</div>
          <div class="code-block">
            <pre><code class="language-bash"># Prevent 429 errors by limiting request rate
# Example: max 2 requests per second
AI_REQUEST_INTERVAL=0.5

# Retry configuration (reactive)
AI_RETRY_ATTEMPTS=5
AI_RETRY_BASE_DELAY=1.0
AI_RETRY_MAX_DELAY=30.0</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Custom retry handler</div>
          <div class="code-block">
            <pre><code class="language-python"># Route retry messages to a queue
# (for rich UIs that don't want console spam)
session = client.get_session()
session.set_retry_callback(
    lambda msg, attempt, max_att, delay:
        status_queue.put({
            "type": "retry",
            "message": msg,
            "attempt": attempt,
            "max_attempts": max_att,
            "delay": delay
        })
)

# Revert to console output
session.set_retry_callback(None)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">How it works</div>
          <div class="code-block">
            <pre><code class="language-text">Request Flow:
        
   Request    > RequestPacer >  API Call    
                   (proactive)                    
     waits if         
                     interval not            
                     elapsed                 v
                        
                                          429 Error?  
                                          with_retry  
                                          (reactive)  
                                        </code></pre>
          </div>
        </div>
      </section>

      <!-- Environment Variables -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="environment-variables">Environment Variables</h2>

          <p>
            Configure jaato behavior via environment variables. Set these in
            your <code>.env</code> file or shell environment.
          </p>

          <h3>Provider Selection</h3>
          <table class="param-table">
            <thead>
              <tr><th>Variable</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>JAATO_PROVIDER</code></td>
                <td>Default provider: <code>google_genai</code>, <code>anthropic</code>, <code>github_models</code>, <code>claude_cli</code>, <code>antigravity</code>, <code>ollama</code></td>
              </tr>
            </tbody>
          </table>

          <h3>General Settings</h3>
          <table class="param-table">
            <thead>
              <tr><th>Variable</th><th>Default</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>AI_USE_CHAT_FUNCTIONS</code></td>
                <td><code>1</code></td>
                <td>Enable function calling mode</td>
              </tr>
              <tr>
                <td><code>JAATO_GC_THRESHOLD</code></td>
                <td><code>80.0</code></td>
                <td>GC trigger threshold %</td>
              </tr>
              <tr>
                <td><code>JAATO_PARALLEL_TOOLS</code></td>
                <td><code>true</code></td>
                <td>Enable parallel tool execution</td>
              </tr>
              <tr>
                <td><code>JAATO_DEFERRED_TOOLS</code></td>
                <td><code>true</code></td>
                <td>Enable deferred tool loading</td>
              </tr>
              <tr>
                <td><code>LEDGER_PATH</code></td>
                <td>-</td>
                <td>Output path for token accounting JSONL</td>
              </tr>
            </tbody>
          </table>

          <h3>Provider-Specific</h3>
          <p>See individual provider docs for their environment variables.</p>
        </div>
        <div class="panel-code">
          <div class="code-label">Example .env file</div>
          <div class="code-block">
            <pre><code class="language-bash"># Provider selection (choose one)
JAATO_PROVIDER=anthropic
MODEL_NAME=claude-sonnet-4-20250514

# Anthropic credentials
ANTHROPIC_API_KEY=sk-ant-api03-...

# Google GenAI credentials (if using google_genai)
# GOOGLE_GENAI_API_KEY=AIza...
# Or for Vertex AI:
# JAATO_GOOGLE_PROJECT=my-gcp-project
# JAATO_GOOGLE_LOCATION=us-central1

# GitHub Models credentials (if using github_models)
# GITHUB_TOKEN=ghp_...

# Ollama (if using ollama)
# OLLAMA_HOST=http://localhost:11434

# General settings
AI_USE_CHAT_FUNCTIONS=1
JAATO_PARALLEL_TOOLS=true
JAATO_DEFERRED_TOOLS=true
JAATO_GC_THRESHOLD=80.0

# Rate limiting
AI_REQUEST_INTERVAL=0.5
AI_RETRY_ATTEMPTS=5</code></pre>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script src="https://unpkg.com/lunr@2.3.9/lunr.min.js"></script>


  <script src="../assets/js/docs.js"></script>
</body>
</html>
