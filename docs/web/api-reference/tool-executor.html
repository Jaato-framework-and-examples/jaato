<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ToolExecutor - jaato docs</title>
  <link rel="stylesheet" href="../assets/css/style.css">
</head>
<body>
  <!-- Header -->
  <header class="header">
    <a href="../index.html" class="header-logo">
      jaato <span>docs</span>
    </a>
    <nav class="header-nav">
      <a href="../getting-started/quickstart.html">Quickstart</a>
      <a href="index.html">API Reference</a>
      <a href="https://github.com/apanoia/jaato" target="_blank">GitHub</a>
      <div class="header-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
        <input type="text" placeholder="Search docs... (press /)">
      </div>
    </nav>
  </header>

  <!-- Layout -->
  <div class="layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">Getting Started</div>
        <ul class="sidebar-nav">
          <li><a href="../getting-started/quickstart.html">Quickstart</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Core Concepts</div>
        <ul class="sidebar-nav">
          <li><a href="../core-concepts/client.html">Client</a></li>
          <li><a href="../core-concepts/plugins.html">Plugins</a></li>
          <li><a href="../core-concepts/tools.html">Tools</a></li>
          <li><a href="../core-concepts/providers.html">Providers</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">API Reference</div>
        <ul class="sidebar-nav">
          <li><a href="index.html">Overview</a></li>
          <li><a href="jaato-client.html">JaatoClient</a></li>
          <li><a href="jaato-runtime.html">JaatoRuntime</a></li>
          <li><a href="jaato-session.html">JaatoSession</a></li>
          <li><a href="plugin-registry.html">PluginRegistry</a></li>
          <li><a href="tool-executor.html" class="active">ToolExecutor</a></li>
          <li><a href="types.html">Types</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Provider Reference</div>
        <ul class="sidebar-nav">
          <li><a href="providers/index.html">Overview</a></li>
          <li><a href="providers/anthropic.html">Anthropic</a></li>
          <li><a href="providers/google-genai.html">Google GenAI</a></li>
          <li><a href="providers/github-models.html">GitHub Models</a></li>
          <li><a href="providers/claude-cli.html">Claude CLI</a></li>
          <li><a href="providers/antigravity.html">Antigravity</a></li>
          <li><a href="providers/ollama.html">Ollama</a></li>
          <li><a href="providers/zhipuai.html">Zhipu AI</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Plugin Reference</div>
        <ul class="sidebar-nav">
          <li><a href="plugins/index.html">Overview</a></li>
          <li><a href="plugins/cli.html">CLI</a></li>
          <li><a href="plugins/file-edit.html">File Edit</a></li>
          <li><a href="plugins/filesystem-query.html">Filesystem Query</a></li>
          <li><a href="plugins/todo.html">Todo</a></li>
          <li><a href="plugins/web-search.html">Web Search</a></li>
          <li><a href="plugins/mcp.html">MCP</a></li>
          <li><a href="plugins/permission.html">Permission</a></li>
          <li><a href="plugins/session.html">Session</a></li>
          <li><a href="plugins/gc.html">GC</a></li>
          <li><a href="plugins/other.html">Other Plugins</a></li>
        </ul>
      </div>
    </aside>

    <!-- Main content -->
    <main class="main">
      <!-- Overview -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h1>ToolExecutor</h1>
          <p class="lead">
            Registry mapping tool names to callable functions with permission checking,
            auto-backgrounding for long-running tasks, and output callbacks for real-time feedback.
          </p>

          <table>
            <tbody>
              <tr><td><strong>Module</strong></td><td><code>shared.ai_tool_runner</code></td></tr>
              <tr><td><strong>Import</strong></td><td><code>from shared import ToolExecutor</code></td></tr>
              <tr><td><strong>Used by</strong></td><td><code>JaatoSession</code>, <code>JaatoClient</code></td></tr>
            </tbody>
          </table>

          <h2 id="features">Features</h2>
          <ul>
            <li><strong>Tool registration</strong> - Map tool names to executor functions</li>
            <li><strong>Permission checking</strong> - Integrate with PermissionPlugin for access control</li>
            <li><strong>Auto-backgrounding</strong> - Long-running tasks auto-convert to background tasks</li>
            <li><strong>Output callbacks</strong> - Real-time streaming output during execution</li>
            <li><strong>Parallel execution</strong> - Thread-safe callbacks for concurrent tool calls</li>
          </ul>

          <div class="callout callout-info">
            <div class="callout-title">Internal Component</div>
            Most users interact with tools through <code>JaatoClient</code> or <code>JaatoSession</code>.
            Direct use of ToolExecutor is typically only needed for advanced customization.
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">Basic usage</div>
          <div class="code-block">
            <pre><code class="language-python">from shared import ToolExecutor

executor = ToolExecutor()

# Register a tool
def my_tool(args):
    return {"result": args.get("input", "") * 2}

executor.register("double_string", my_tool)

# Execute the tool
success, result = executor.execute(
    "double_string",
    {"input": "hello"}
)
# result: {"result": "hellohello"}</code></pre>
          </div>
        </div>
      </section>

      <!-- Constructor -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="constructor">Constructor</h2>
          <p>
            Creates a new ToolExecutor instance with optional configuration for
            token ledger and auto-background behavior.
          </p>

          <h3>Parameters</h3>
          <table>
            <thead>
              <tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>ledger</code></td>
                <td><code>TokenLedger</code></td>
                <td><code>None</code></td>
                <td>Token ledger for recording execution events</td>
              </tr>
              <tr>
                <td><code>auto_background_enabled</code></td>
                <td><code>bool</code></td>
                <td><code>True</code></td>
                <td>Enable auto-backgrounding for long-running tasks</td>
              </tr>
              <tr>
                <td><code>auto_background_pool_size</code></td>
                <td><code>int</code></td>
                <td><code>4</code></td>
                <td>Thread pool size for background execution</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="panel-code">
          <div class="code-label">Constructor</div>
          <div class="code-block">
            <pre><code class="language-python">from shared import ToolExecutor
from shared.token_accounting import TokenLedger

# Default configuration
executor = ToolExecutor()

# With token ledger
ledger = TokenLedger()
executor = ToolExecutor(ledger=ledger)

# Custom background pool
executor = ToolExecutor(
    auto_background_enabled=True,
    auto_background_pool_size=8
)</code></pre>
          </div>
        </div>
      </section>

      <!-- Registration Methods -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="registration">Registration Methods</h2>

          <h3><code>register(name, fn)</code></h3>
          <p>
            Register a tool executor function under a given name.
          </p>
          <table>
            <thead>
              <tr><th>Parameter</th><th>Type</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>name</code></td>
                <td><code>str</code></td>
                <td>Tool name to register</td>
              </tr>
              <tr>
                <td><code>fn</code></td>
                <td><code>Callable[[Dict], Any]</code></td>
                <td>Function that accepts args dict and returns result</td>
              </tr>
            </tbody>
          </table>

          <h3><code>clear_executors()</code></h3>
          <p>
            Clear all registered executors. Useful when refreshing tools
            after enabling/disabling plugins.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Tool registration</div>
          <div class="code-block">
            <pre><code class="language-python"># Register tools
def greet(args):
    name = args.get("name", "World")
    return {"message": f"Hello, {name}!"}

def calculate(args):
    a = args.get("a", 0)
    b = args.get("b", 0)
    op = args.get("op", "add")
    if op == "add":
        return {"result": a + b}
    elif op == "multiply":
        return {"result": a * b}

executor.register("greet", greet)
executor.register("calculate", calculate)

# Clear all tools
executor.clear_executors()</code></pre>
          </div>
        </div>
      </section>

      <!-- Execute Method -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="execute">execute()</h2>
          <p>
            Execute a tool by name with the given arguments. Handles permission
            checking, auto-backgrounding, and output callbacks automatically.
          </p>

          <h3>Parameters</h3>
          <table>
            <thead>
              <tr><th>Parameter</th><th>Type</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>name</code></td>
                <td><code>str</code></td>
                <td>Tool name to execute</td>
              </tr>
              <tr>
                <td><code>args</code></td>
                <td><code>Dict[str, Any]</code></td>
                <td>Arguments to pass to the tool</td>
              </tr>
              <tr>
                <td><code>tool_output_callback</code></td>
                <td><code>Callable[[str], None]</code></td>
                <td>Optional callback for streaming output</td>
              </tr>
              <tr>
                <td><code>call_id</code></td>
                <td><code>str</code></td>
                <td>Optional unique identifier for parallel execution</td>
              </tr>
            </tbody>
          </table>

          <h3>Returns</h3>
          <p>
            <code>Tuple[bool, Any]</code> - Success flag and result (or error dict).
          </p>

          <h3>Result Structure</h3>
          <p>
            On success, returns the tool's result. On failure, returns a dict:
          </p>
          <ul>
            <li><code>error</code> - Error message</li>
            <li><code>traceback</code> - Full traceback (if exception)</li>
            <li><code>_permission</code> - Permission metadata (if applicable)</li>
          </ul>

          <h3>Executor Metadata</h3>
          <p>
            Executors may return a <code>(result_dict, metadata_dict)</code> tuple.
            The metadata is merged into the result dict before it is returned.
          </p>
          <table>
            <thead>
              <tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>continuation_id</code></td>
                <td><code>str</code></td>
                <td>â€”</td>
                <td>Groups consecutive tool calls into a single popup session</td>
              </tr>
              <tr>
                <td><code>show_output</code></td>
                <td><code>bool</code></td>
                <td><code>true</code></td>
                <td>Controls main output panel visibility for this call</td>
              </tr>
              <tr>
                <td><code>show_popup</code></td>
                <td><code>bool</code></td>
                <td><code>true</code></td>
                <td>Controls popup panel tracking/visibility for this call</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="panel-code">
          <div class="code-label">Executing tools</div>
          <div class="code-block">
            <pre><code class="language-python"># Basic execution
success, result = executor.execute(
    "greet",
    {"name": "Alice"}
)
if success:
    print(result["message"])
    # "Hello, Alice!"

# With output callback for streaming
def on_output(chunk):
    print(f"[stream] {chunk}")

success, result = executor.execute(
    "long_running_task",
    {"input": "data"},
    tool_output_callback=on_output
)

# With call_id for parallel execution
success, result = executor.execute(
    "analyze",
    {"file": "data.csv"},
    call_id="call_12345"
)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Executor metadata tuple</div>
          <div class="code-block">
            <pre><code class="language-python"># Executor returning metadata:
def _exec_input(self, args):
    result = {"output": "..."}
    return (result, {
        "continuation_id": "sess_1",
        "show_output": False,
    })

# ToolExecutor merges metadata into result:
success, result = executor.execute(
    "shell_input", {"session_id": "sess_1", "text": "ls"}
)
# result == {"output": "...", "continuation_id": "sess_1",
#            "show_output": False}</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Error handling</div>
          <div class="code-block">
            <pre><code class="language-python">success, result = executor.execute(
    "unknown_tool",
    {}
)

if not success:
    print(result["error"])
    # "No executor registered for unknown_tool"

# Permission denied
success, result = executor.execute(
    "dangerous_tool",
    {"cmd": "rm -rf /"}
)
if not success and "_permission" in result:
    print(f"Denied: {result['error']}")
    print(f"Method: {result['_permission']['method']}")</code></pre>
          </div>
        </div>
      </section>

      <!-- Permission Integration -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="permissions">Permission Integration</h2>
          <p>
            The ToolExecutor integrates with <a href="plugins/permission.html">PermissionPlugin</a>
            to check permissions before executing tools.
          </p>

          <h3><code>set_permission_plugin(plugin, context)</code></h3>
          <table>
            <thead>
              <tr><th>Parameter</th><th>Type</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>plugin</code></td>
                <td><code>PermissionPlugin</code></td>
                <td>Permission plugin instance, or <code>None</code> to disable</td>
              </tr>
              <tr>
                <td><code>context</code></td>
                <td><code>Dict[str, Any]</code></td>
                <td>Optional context for permission checks (e.g., session_id)</td>
              </tr>
            </tbody>
          </table>

          <h3>Permission Metadata</h3>
          <p>
            When permissions are checked, metadata is injected into the result:
          </p>
          <ul>
            <li><code>decision</code> - <code>"allowed"</code> or <code>"denied"</code></li>
            <li><code>reason</code> - Explanation of the decision</li>
            <li><code>method</code> - How the decision was made (whitelist, interactive, etc.)</li>
          </ul>
        </div>
        <div class="panel-code">
          <div class="code-label">Permission configuration</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.plugins.permission import PermissionPlugin

# Create permission plugin
permission = PermissionPlugin(
    config_path=".jaato/permissions.json",
    channel_type="console"
)

# Set on executor
executor.set_permission_plugin(
    permission,
    context={"session_id": "abc123"}
)

# Now all executions check permissions
success, result = executor.execute(
    "deleteFile",
    {"path": "/etc/passwd"}
)
# User prompted for permission (if not whitelisted/blacklisted)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Permission metadata in result</div>
          <div class="code-block">
            <pre><code class="language-python">success, result = executor.execute(
    "writeFile",
    {"path": "output.txt", "content": "data"}
)

if "_permission" in result:
    perm = result["_permission"]
    print(f"Decision: {perm['decision']}")
    print(f"Reason: {perm['reason']}")
    print(f"Method: {perm['method']}")</code></pre>
          </div>
        </div>
      </section>

      <!-- Auto-Background -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="auto-background">Auto-Background</h2>
          <p>
            Tools from <code>BackgroundCapable</code> plugins can be automatically
            converted to background tasks when they exceed a time threshold.
          </p>

          <h3>How It Works</h3>
          <ol>
            <li>Tool starts executing</li>
            <li>If execution exceeds threshold (e.g., 30s), it continues in background</li>
            <li>Returns immediately with task handle</li>
            <li>Use background plugin to check status and get results</li>
          </ol>

          <h3>Auto-Background Result</h3>
          <p>When a task is auto-backgrounded, the result contains:</p>
          <ul>
            <li><code>auto_backgrounded</code> - <code>true</code></li>
            <li><code>task_id</code> - ID to check status</li>
            <li><code>plugin_name</code> - Plugin that owns the task</li>
            <li><code>tool_name</code> - Original tool name</li>
            <li><code>threshold_seconds</code> - Threshold that was exceeded</li>
            <li><code>message</code> - Human-readable explanation</li>
          </ul>
        </div>
        <div class="panel-code">
          <div class="code-label">Auto-background result</div>
          <div class="code-block">
            <pre><code class="language-python"># Tool exceeds threshold
success, result = executor.execute(
    "runCommand",
    {"command": "npm install"}  # Takes > 30s
)

if result.get("auto_backgrounded"):
    task_id = result["task_id"]
    print(f"Task backgrounded: {task_id}")
    print(result["message"])
    # "Task exceeded 30s threshold, continuing
    #  in background. Use task_id 'cli_abc123'
    #  to check status and output."</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Check background task</div>
          <div class="code-block">
            <pre><code class="language-python"># Use background plugin to check status
checkBackgroundTask(task_id="cli_abc123")
# {"task_id": "cli_abc123", "status": "running"}

# Get output when complete
getBackgroundOutput(task_id="cli_abc123")
# {"status": "completed", "result": {...}}</code></pre>
          </div>
        </div>
      </section>

      <!-- Output Callbacks -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="callbacks">Output Callbacks</h2>
          <p>
            ToolExecutor supports two types of callbacks for real-time output
            during tool execution.
          </p>

          <h3><code>set_output_callback(callback)</code></h3>
          <p>
            Set the general output callback, forwarded to all plugins that
            support it. Used for agent-level output streaming.
          </p>

          <h3><code>set_tool_output_callback(callback)</code></h3>
          <p>
            Set the tool-specific output callback. Set per-tool-call to route
            output to the correct tool tree entry in the UI.
          </p>

          <h3>Parallel Execution</h3>
          <p>
            For parallel tool execution, callbacks are stored in thread-local
            storage. Pass <code>tool_output_callback</code> to <code>execute()</code>
            to set it for that specific call.
          </p>

          <h3><code>get_current_tool_output_callback()</code></h3>
          <p>
            Module-level function for plugins to get the current thread's callback
            during parallel execution.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Output callbacks</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.ai_tool_runner import (
    ToolExecutor,
    get_current_tool_output_callback
)

executor = ToolExecutor()

# General output callback
def on_output(source, text, mode):
    print(f"[{source}] {text}")

executor.set_output_callback(on_output)

# Tool-specific callback
def on_tool_output(chunk):
    print(f"[tool] {chunk}")

executor.set_tool_output_callback(on_tool_output)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Parallel execution</div>
          <div class="code-block">
            <pre><code class="language-python">from concurrent.futures import ThreadPoolExecutor

def run_tool(tool_name, args, call_id):
    def callback(chunk):
        print(f"[{call_id}] {chunk}")

    return executor.execute(
        tool_name,
        args,
        tool_output_callback=callback,
        call_id=call_id
    )

# Execute tools in parallel
with ThreadPoolExecutor(max_workers=4) as pool:
    futures = [
        pool.submit(run_tool, "analyze", {"f": "a.py"}, "call_1"),
        pool.submit(run_tool, "analyze", {"f": "b.py"}, "call_2"),
    ]
    results = [f.result() for f in futures]</code></pre>
          </div>
        </div>
      </section>

      <!-- Configuration Methods -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="configuration">Configuration Methods</h2>

          <h3><code>set_ledger(ledger)</code></h3>
          <p>
            Set the <code>TokenLedger</code> for recording execution events
            (permission checks, auto-background, etc.).
          </p>

          <h3><code>set_registry(registry)</code></h3>
          <p>
            Set the <code>PluginRegistry</code> for plugin lookups. Required
            for auto-background support and dynamic tool discovery.
          </p>

          <h3><code>get_output_callback()</code></h3>
          <p>Returns the current general output callback.</p>

          <h3><code>get_tool_output_callback()</code></h3>
          <p>
            Returns the current tool output callback. Checks thread-local
            storage first (for parallel execution), then instance-level.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Configuration</div>
          <div class="code-block">
            <pre><code class="language-python">from jaato import PluginRegistry
from shared import ToolExecutor
from shared.token_accounting import TokenLedger

executor = ToolExecutor()

# Set ledger for event recording
ledger = TokenLedger()
executor.set_ledger(ledger)

# Set registry for plugin lookups
registry = PluginRegistry()
registry.expose_all()
executor.set_registry(registry)

# Get current callbacks
output_cb = executor.get_output_callback()
tool_cb = executor.get_tool_output_callback()</code></pre>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script src="https://unpkg.com/lunr@2.3.9/lunr.min.js"></script>
  <script src="../assets/js/docs.js"></script>
</body>
</html>
