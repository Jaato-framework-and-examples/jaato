#!/usr/bin/env python3
"""
Create a self-extracting Bash script from any payload.
The generated script will extract and optionally execute the embedded content.

Usage:
    python create_self_extractor.py payload.tar.gz output.sh
    python create_self_extractor.py setup.sh installer.sh --execute
    python create_self_extractor.py config.json deploy.sh --output prod_config.json
"""
import base64
import argparse
import sys
from pathlib import Path


def create_self_extractor(
    payload_path: str,
    output_script: str,
    execute: bool = False,
    output_filename: str = None,
    description: str = None
) -> None:
    """
    Create a self-extracting Bash script from a payload file.
    
    Args:
        payload_path: Path to the file to embed
        output_script: Path for the generated script
        execute: If True, execute the extracted file after extraction
        output_filename: Custom filename for extracted content
        description: Description to include in script header
    """
    payload = Path(payload_path)
    if not payload.exists():
        raise FileNotFoundError(f"Payload not found: {payload_path}")
    
    # Read and encode payload
    with open(payload, "rb") as f:
        encoded = base64.b64encode(f.read()).decode("ascii")
    
    # Determine output filename
    extract_name = output_filename or payload.name
    
    # Build description
    desc = description or f"Self-extracting script containing: {payload.name}"
    
    # Generate the self-extracting script
    script_content = f'''#!/bin/bash
# {desc}
# Generated by self-extracting-script skill
# 
# Usage: bash {Path(output_script).name}
#        ./{Path(output_script).name}
#
# This script will extract: {extract_name}

set -e

OUTPUT_FILE="${{1:-{extract_name}}}"

echo "Extracting: $OUTPUT_FILE"

# Decode and extract the embedded payload
base64 -d << 'EOF_PAYLOAD' > "$OUTPUT_FILE"
{encoded}
EOF_PAYLOAD

echo "✅ Extracted: $OUTPUT_FILE"
'''
    
    # Add execution logic if requested
    if execute:
        script_content += f'''
# Make executable and run
chmod +x "$OUTPUT_FILE"
echo "Running: $OUTPUT_FILE"
echo "---"
./"$OUTPUT_FILE"
'''
    
    # Write the script
    output_path = Path(output_script)
    with open(output_path, "w") as f:
        f.write(script_content)
    
    # Make it executable
    output_path.chmod(0o755)
    
    print(f"✅ Created self-extracting script: {output_script}")
    print(f"   Payload: {payload.name} ({payload.stat().st_size:,} bytes)")
    print(f"   Encoded size: {len(encoded):,} bytes")
    if execute:
        print(f"   Auto-execute: enabled")


def main():
    parser = argparse.ArgumentParser(
        description="Create a self-extracting Bash script from any payload"
    )
    parser.add_argument(
        "payload",
        help="Path to the file to embed"
    )
    parser.add_argument(
        "output_script",
        help="Path for the generated self-extracting script"
    )
    parser.add_argument(
        "--execute", "-e",
        action="store_true",
        help="Execute the extracted file after extraction"
    )
    parser.add_argument(
        "--output", "-o",
        dest="output_filename",
        help="Custom filename for the extracted content"
    )
    parser.add_argument(
        "--description", "-d",
        help="Description to include in the script header"
    )
    
    args = parser.parse_args()
    
    try:
        create_self_extractor(
            payload_path=args.payload,
            output_script=args.output_script,
            execute=args.execute,
            output_filename=args.output_filename,
            description=args.description
        )
    except FileNotFoundError as e:
        print(f"❌ Error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"❌ Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
